
## 基本块
	基本块是满足条件的最大的连续三地址指令序列。
		说白了。就是基本块里面的指令是一个整体，按照顺序执行。
![image-20251203202231909](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203202231909.png)

### 如何确定基本块？

	首先需要确定首指令，从首指令到第二个首指令之间的就构成了基本块。
	第一条指令是首指令；
	跳转指令跳转的指令是首指令；
	紧跟在跳转指令后的指令是首指令。
	如上图，因此基本块划分关键就是找出首指令，然后第一条首指令i1，到第二条首指令i2之间的指令，就是[i1,i2)就组成了基本块。
![image-20251203203136931](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203203136931.png)

![image-20251203203733268](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203203733268.png)

## 流图

	描述程序控制流程的工具。
	流图的结点是一些基本块。
	若基本块B是C的前驱块，C是B的后继块，那么基本块B和C之间有一条边。
	如何确定这条边？
		如上图；
	想要说明的是这里的“可能”关键词，因此在第二条规则里面，我们是要求B不能由无条件跳转指令，有条件跳转指令表示B还有可能是C的的前驱基本块。
	说白了，就是满足条件的B和C一定要可能“连续”。
	最后把三地址指令添加到构建“成功的流图”，那么就是我们想要的指令流图了。
## 常见代码优化方法
### 引言
	代码优化分为机器无关优化（针对中间代码）和机器相关优化（针对目标代码）。
	又可分为局部代码优化（单个基本块范围内的优化）和全局代码优化（面向多个基本块的优化）。
![image-20251203204509801](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203204509801.png)

![image-20251203204740002](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203204740002.png)

![image-20251203205047211](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203205047211.png)

### 删除公共子表达式

	说白了，就是要求这个表达式的操作数不能改变。
	先构建流图，然后找到重复的公共表达式（一定要看它的值有没有被改变），然后用已有的替换掉被删除的表达式即可。
	看图2，是针对局部公共子表达式而言；
	看图3，是针对全局公共子表达式而言。
![image-20251203210159915](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210159915.png)

### 删除无用代码

	先看复制传播，常用的公共子表达式消除算法和其他的一些优化算法可能会引入一些复制语句，（如x=y的赋值语句）。
	复制传播：在复制语句x=y之后尽可能使用y来代替x。
	虽然它不是代码优化的方法，但是它为删除无用代码带来的机会。
	无用代码（死代码）：计算结果永远不会被使用的语句。
![image-20251203210321087](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210321087.png)

### 常量合并
	如上图。


![](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210544689.png)

![image-20251203210602738](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210602738.png)

![image-20251203210723600](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210723600.png)

### 代码移动

	如上图
![image-20251203210909028](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203210909028.png)

![image-20251203211716227](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203211716227.png)

### 强度削弱

	重点要就循环中的强度削弱。
![image-20251203212456508](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251203212456508.png)

### 删除归纳变量



## DAG图



![image-20251204090951375](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251204090951375.png)
### 构建方法
	如上图。
	此外，DAG图中内部节点都是代表运算操作，而叶子结点代表了操作数，就是原始输入。
![image-20251204091324795](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251204091324795.png)

### 作用

	1，删除局部公共子表达式 （构建方法上的那张图）
	2.删除无关代码（如上图）
		其实就是看给出的DAG图的根节点，看它是不是活跃变量，看它后面会不会被利用，也就是看根节点，如果根节点不是活跃变量，那么将结点删除；然后重复这样的过程即可。
![image-20251204104719000](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251204104719000.png)

### 防止误判为公共子表达式

	以数组元素赋值指令为例
![image-20251204113115821](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251204113115821.png)

## 例子

	下面通过一个例子说明如何由给出的指令序列构建DAG图，然后根据DAG图来删除无用代码和公共子表达式来实现代码优化。
	先构建DAG图，如右边，然后删除无用代码，只有L是基本块出口后的活跃变量，因此将根节点G删除；（利用公共子表达式：）然后对于一个节点处有多个定值变量，我们只保留一个定值变量，一般保留活跃变量，但是没有的话，保留其中一个就可以了；常量合并，对于可以直接计算出的变量，我们在后面用常量代替它即可。然后在根据每条指令来重写指令即可。
![image-20251204121116299](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251204121116299.png)

## 节点集

	在指令流图的基础上，如果求结点Bi的节点集，那么从我的理解就是从初始节点到Bi的最短路径，在最短路径的过程中，把其他节点加入其中，但是最短路径可能有两条，我们以例题为例。如上图
		B1就是我说的初始节点，那么最短路径就是只有B1；
		B2的节点集就是从B1出发到B2，发现最短路径是B1，B2；
		B3我们发现有好几条路径可以到B3，依旧选最短的，B1——B2——B3‘
		B4依旧最短B1--B2--B3；
		B5依旧；
		B6依旧；
		B7有两条最短路径，然后节点集选择的是必经的结点然后加入到集合中，现在6或者7都可以构成最短的，因此我们选择都不选，不把6或者7加入集合；
		B8也是一样的，不把6或者7加入。

## 回边
	在节点集中找，集合中如果存在两个节点ni，nj，i<j，如果存在nj指向ni，那么这就是回边。
## 循环
	在回边的基础上，如回边A->B，那么循环计算方法就是B∪{不经过B就能到达A的结点集合}。
## 活跃变量分析

![image-20251205114023915](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205114023915.png)

![image-20251205114004331](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205114004331.png)

### 活跃变量
	说白了，活跃变量就是“当前值”在后面的程序中需要被引用，如果当前值发生改变，就是被重新赋值，那么重新赋值后的就是当前值，然后再看在后续有没有在被引用。
#### 人工活跃变量分析
	看上图的例子，i在基本块2的出口处，因为后续一定会经过B4，而B4对i进行了重新赋值，因此不活跃，然后i在B4的出口处，虽然i被重新赋值为“当前值”，但是在B2中又被引用了，因此也是活跃变量。
![image-20251205114804468](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205114804468.png)

### 用途

![image-20251205115514124](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205115514124.png)

### 活跃变量传递函数
	x是在B的出口处活跃的变量的集合，这里面的集合包括了在B中被重新定义的变量；
	fB(x)是在B的入口处活跃的变量的集合。
	useB就是在B中首次出现并以引用的形式出现的集合；
	defB是在B中首次出现但是以定值的形式出现的集合。
	因此fB(x)=useB∪{x-defB}；
![image-20251205120249413](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205120249413.png)

#### 例子
	上述例子是用来求uesB和defB的
![image-20251205122742766](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205122742766.png)

![image-20251205122908170](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205122908170.png)

![image-20251205123606115](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205123606115.png)

#### 利用活跃变量数据流方程分析活跃变量

	在上面我们用过人工分析活跃变量，这里就是机器分析。
	这个算法要求我们先计算useB和defB。
	然后在两个（不是两层）循环中计算，第一个循环将每个Bi的IN函数设置为空；在第二个循环里面，这是个双层循环，外层循环判断条件是Bi的IN函数发生变化，内层循环是便利每一个Bi，内容是计算OUT和IN，OUT计算方法就是它的后继结点的IN的并集，IN计算方法就是useB∪{OUTB-defB}，然后每个Bi的OUT和IN计算完成后，看IN是否发生改变，改变的话计算在现有的IN基础上进行计算，如果不改变说明就是最后想要的IN和OUT函数，入口和出口处的活跃变量就可以得出来了。
	看图可以发现，这和我们人工分析结果是一致的。
![image-20251205183826338](C:\Users\wang'zhen'yu\AppData\Roaming\Typora\typora-user-images\image-20251205183826338.png)

## 线性扫描算法
	前提知识：先去学活跃变量，然后针对基本块如何计算IN，OUT，use，def集合，还有将一条语句看成一个语句块进行计算也要掌握，这是学下面的前提；
	 直接说怎么做吧。
	 1.先划分活跃区间
	   		首先对于对于给定的一堆式子，我们进行活跃变量分析，这里的活跃变量分析和前面的不一样，前面的是针对于基本块进行计算IN，OUT集合等，但是这里我们将每条语句看成是一个基本块，然后接下来介绍具体如何求解：先求每条语句的use和def集合，然后求解IN和OUT集合，求解方法就不赘述了，上面的笔记有的，直接带公式就行了；然后针对在每个语句上下方写出对应的IN，OUT集合，然后划分活跃区间：开始位置start就是a最开始出现对应的那条指令，结束位置end就是a最后出现对应的指令。然后将区间[start,end]按照start的顺序进行从小到大排序；然后格式可以参考上面的图片；
	 2.利用算法实现
	   		在讲解算法实现之前，先说几个东西，ACTIVE表：是存放已经被分配寄存器的活跃区间（把活跃区间看成是一个东西就好，放在ACTIVE表里面，或者ACTIVE集合），寄存器（题目中一般会说给几个寄存器，实际上就是因为寄存器不够才需要这个算法的），可获得的寄存器（除去已经被占用的寄存器），被分割的区间（直译过来是这样的....存放的是无法被分配寄存器的活跃区间），已经分析完的活跃区间（名字我具体也喊不上来，就是存放已经被扫描完的活跃区间），其实这几个东西就是上述表格的那四列属性。
	   		具体的算法就是：现在假设轮到扫描活跃区间Bi，如果这时候寄存器还有剩余，就是可用寄存器不为空，那么就把寄存器分配给该活跃区间；如果这时候寄存器无了，但是正好已经有一个区间分析完毕（条件一定是已经分析完毕的活跃区间的end值小于该扫描区间的start值，一定是小于，而不是小于等于！！！），那么让分析完的区间对应的寄存器空出来给该区间；如果寄存器无了，并且其他区间也都在分析中，那么我们将ACTIVE表中的每个活跃区间和该活跃区间进行比较，将end（还记得吗，就是区间的结束位置）从大到小排序，找出最大的然后放入被分割的区间这个集合中，如果最大的是该区间，那么将它放入集合中，如果最大的在ACTIVE中，那么将它对应的寄存器给该活跃区间，并将它放入被分割的区间这个集合中。
	   		然后如果分析完毕，那么将其放入已经分析完的活跃区间的集合中，并将寄存器空出。
	   		起初时候，可获得的寄存器（后面用ar缩写代替了）是满的，ACTIVE表是空的，被分割的区间（si）也是空的，已经分析完的活跃区间（ar）是空的；然后从指令1开始分析，将寄存器r1给活跃区间A；然后扫描指令2，将r2给活跃区间B；然后扫描指令3没有空余的寄存器ar了，因此将ACTIVE里每个活跃区间的end值和C的end比较，发现C的end值大，因此将C放入si集合；继续扫描，轮到区间D，这时候A扫描完毕，r1空出来了，给D，同时ar中把A加入；然后扫描E，这时候B扫描结束，r2给E，B加入到ar；然后E扫描完毕，r2空出来，E加入到ar；最后D分析完毕，r1空出来，D加入到ar。


## 图着色算法
	课件上的那个算法很迷糊，其实并没有给出很具体的算法。
	前提知识：和线性扫描不一样，这里只用IN和OUT集合就够了，用活跃区间反而会麻烦。所以先需要的知识是：use，def，IN，OUT，结点的度；需要的数据结构：栈，图
	方法概要：
	假设有k个寄存器可以使用。
	第一步：计算出每条语句的IN和OUT集合，将他们分别标在语句的上面和下面；
	第二步：构建寄存器冲突图
		什么是冲突图？反正就是一个图，学过数据结构应该就了解，然后每个节点就是一个变量（a，b，c之类的），下面介绍变量也就是结点之间的边如何构建，在IN集合里面出现的变量将他们之间彼此用一条边连接，比如IN集合{a，b，c}，那么a，b，c直接分别用一条边相连；然后OUT集合也是一样的，这样冲突图就构建出来了；
	第三步：结点入栈
		将度小于k（不能等于）的结点移入栈内，持续这个操作，最后剩下的要么是空图；要么是度都大于等于k的结点；
	第四步：结点出栈/溢出阶段分析，着色
		对于空图，我们将结点出栈，然后给出栈的结点和已出站的结点之间原来的线重新恢复，并将刚出栈的结点上色，要求不能和连线的结点的颜色重复，重复这个操作即可；如果不是空图，那么需要选取结点进行溢出处理，选取的节点不是随便选的，如果只是应付考试，其实可以看它的活跃频率，就是在IN和OUT集合出现的频率，然后选取频率低的做溢出处理，其就是将其出栈，然后重复3,4步的分析即可。
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	
​	